
import os, sys

sys.path.append("..")

import BNL
import matplotlib.pyplot as plt
import numpy as np
from particle import Particle
from tracker import Tracker
from particle_log import StateList

deu = Particle()
deu.kinetic_energy += .5e-6*deu.kinetic_energy
deu.gamma -= deu.gamma*2e-5/1.42
lattice = BNL.make_lattice(deu)

trkr = Tracker()
bunch = StateList(Sz=1, dK=np.linspace(-2.5e-3, 2.5e-3, 30))

# mean_angle = float(input("Mean tilt angle: "))
# sigma_angle = float(input("Sigma: "))
    
# lattice.tilt('s', mean_angle, sigma_angle)

n_turns = 500 #int(input("Number of turns: "))
log = trkr.track(deu, bunch, lattice, n_turns)

lattice.make_segment('OUT')
lattice.plot_segment('OUT', log, 'dK', 's')

dK = log['dK']
s = log['s']

from scipy import optimize
def fit_leastsq(p0, datax, datay, function):

    errfunc = lambda p, x, y: function(x, p) - y

    pfit, pcov, infodict, errmsg, success = \
        optimize.leastsq(errfunc, p0, args=(datax, datay), \
                          full_output=1, epsfcn=0.0001)

    if (len(datay) > len(p0)) and pcov is not None:
        s_sq = (errfunc(pfit, datax, datay)**2).sum()/(len(datay)-len(p0))
        pcov = pcov * s_sq
    else:
        pcov = np.inf

    error = [] 
    for i in range(len(pfit)):
        try:
          error.append(np.absolute(pcov[i][i])**0.5)
        except:
          error.append( 0.00 )
    pfit_leastsq = pfit
    perr_leastsq = np.array(error) 
    return pfit_leastsq, perr_leastsq 

#***********************************************************
rf = lattice.get_RF()
guess_ampl = dK.std(axis=0)
guess_wfrq = rf.freq*2*np.pi*np.ones_like(guess_ampl)
guess_phase = np.zeros_like(guess_ampl)
guess_mean = dK.mean(axis=0)

est = np.array([leastsq(lambda x: x[0]*np.cos(x[1]*s[:, pid] + x[2]) + x[3] - dK[:, pid],
                        [guess_ampl[pid], guess_wfrq[pid], guess_phase[pid], guess_mean[pid]])[0]
                for pid in range(19)])


from pandas import DataFrame
est_df=DataFrame(est, columns=['ampl','wfrq', 'phase', 'mean'])
#**************************************************************

p_start = np.array([guess_ampl, guess_wfrq, guess_phase, guess_mean]).T
f = lambda s, p: p[0]*np.cos(p[1]*s + p[2]) + p[3]
est = [fit_leastsq(p_start[pid], s[:, pid], dK[:, pid], f) for pid in range(19)]

dK0 = dK[0]
plt.errorbar(dK0, mean_dK, yerr=std_dK, fmt='--.')
plt.xlabel('dK_0')
plt.ylabel('<dK>_'+str(n_turns))
plt.title('mean dK, {} turns, pids w/in  separatrix (7--24)'.format(n_turns));
plt.show()



