/*  Vector field function and events for Dopri853 integrator.
  This code was automatically generated by PyDSTool, but may be modified by hand. */

#include <math.h>
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "events.h"
#include "maxmin.h"
#include "signum.h"
#include "vfield.h"

extern double *gICs;
extern double **gBds;
extern double globalt0;

static double pi = 3.1415926535897931;

double signum(double x)
{
  if (x<0) {
    return -1;
  }
  else if (x==0) {
    return 0;
  }
  else if (x>0) {
    return 1;
  }
  else {
    /* must be that x is Not-a-Number */
    return x;
  }
}


/* Variable, aux variable, parameter, and input definitions: */ 
#define Curve	p_[0]
#define G	p_[1]
#define KinEn0	p_[2]
#define Length	p_[3]
#define Mass0	p_[4]
#define clight	p_[5]
#define q	p_[6]
#define dK	Y_[0]
#define px	Y_[1]
#define py	Y_[2]
#define x	Y_[3]
#define y	Y_[4]


double Bs(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Bx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double By(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Es(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Ex(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Ey(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Fx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double Fy(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double KinEn(double __dK__, double *p_, double *wk_, double *xv_);
double Lbeta(double __dK__, double *p_, double *wk_, double *xv_);
double Lgamma(double __dK__, double *p_, double *wk_, double *xv_);
double Pc(double __dK__, double *p_, double *wk_, double *xv_);
double Ps(double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_);
double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_);
double globalindepvar(double t, double *p_, double *wk_, double *xv_);
double initcond(char *varname, double *p_, double *wk_, double *xv_);
double pxprime(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double tprime(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double vs(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double vx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double vy(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double xprime(double __x__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
double yprime(double __x__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_);
int getindex(char *name, double *p_, double *wk_, double *xv_);
int heav(double x_, double *p_, double *wk_, double *xv_);

int N_EVENTS = 0;
void assignEvents(EvFunType *events){
 
}

void auxvars(unsigned, unsigned, double, double*, double*, double*, unsigned, double*, unsigned, double*);
void jacobian(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
void jacobianParam(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
int N_AUXVARS = 0;


int N_EXTINPUTS = 0;


void vfieldfunc(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){
/* reused term definitions */
double pxp = pxprime(x,y,px,py,dK, p_, wk_, xv_);
double xp = xprime(x,px,py,dK, p_, wk_, xv_);
double yp = yprime(x,px,py,dK, p_, wk_, xv_);

f_[0] = sin(t);
f_[1] = pxp;
f_[2] = 0;
f_[3] = xp;
f_[4] = yp;

}




double Bs(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 0 ;

}


double Bx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 0 ;

}


double By(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 0 ;

}


double Es(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 0 ;

}


double Ex(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 1e6 ;

}


double Ey(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 0 ;

}


double Fx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return q*(Ex(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)+vy(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)*Bs(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)-By(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)*vs(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_));

}


double Fy(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return q*(Ey(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)+vs(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)*Bx(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)-Bs(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)*vx(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_));

}


double KinEn(double __dK__, double *p_, double *wk_, double *xv_) {


return KinEn0*(1+__dK__);

}


double Lbeta(double __dK__, double *p_, double *wk_, double *xv_) {


return sqrt(pow(Lgamma(__dK__, p_, wk_, xv_),2)-1)/Lgamma(__dK__, p_, wk_, xv_);

}


double Lgamma(double __dK__, double *p_, double *wk_, double *xv_) {


return KinEn(__dK__, p_, wk_, xv_)/Mass0+1 ;

}


double Pc(double __dK__, double *p_, double *wk_, double *xv_) {


return sqrt(pow(Mass0+KinEn(__dK__, p_, wk_, xv_),2)-pow(Mass0,2));

}


double Ps(double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return pow(Pc(__dK__, p_, wk_, xv_),2)-pow(Pc(0, p_, wk_, xv_),2)*(pow(__px__,2)+pow(__py__,2));

}


double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ > e2_) {return e1_;} else {return e2_;};
}


double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {return e3_;} else {return temp_;};
}


double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {temp_ = e3_;};
if (e4_ > temp_) {return e4_;} else {return temp_;};
}


double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ < e2_) {return e1_;} else {return e2_;};
}


double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {return e3_;} else {return temp_;};
}


double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {temp_ = e3_;};
if (e4_ < temp_) {return e4_;} else {return temp_;};
}


double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_) {
  if (cond_) {return e1_;} else {return e2_;};
}


double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_) {
  return gBds[which_bd][getindex(name, p_, wk_, xv_)];
}


double globalindepvar(double t, double *p_, double *wk_, double *xv_) {
  return globalt0+t;
}


double initcond(char *varname, double *p_, double *wk_, double *xv_) {

  if (strcmp(varname, "dK")==0)
	return gICs[0];
  else if (strcmp(varname, "px")==0)
	return gICs[1];
  else if (strcmp(varname, "py")==0)
	return gICs[2];
  else if (strcmp(varname, "x")==0)
	return gICs[3];
  else if (strcmp(varname, "y")==0)
	return gICs[4];
  else {
	fprintf(stderr, "Invalid variable name %s for initcond call\n", varname);
	return 0.0/0.0;
	}
}


double pxprime(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return Fx(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)*tprime(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_)+Curve*Ps(__px__,__py__,__dK__, p_, wk_, xv_);

}


double tprime(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return (1+Curve*__x__)/(clight*Lbeta(__dK__, p_, wk_, xv_))*Pc(__dK__, p_, wk_, xv_)/Ps(__px__,__py__,__dK__, p_, wk_, xv_);

}


double vs(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return 1/tprime(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_);

}


double vx(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return xprime(__x__,__px__,__py__,__dK__, p_, wk_, xv_)/tprime(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_);

}


double vy(double __x__, double __y__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return yprime(__x__,__px__,__py__,__dK__, p_, wk_, xv_)/tprime(__x__,__y__,__px__,__py__,__dK__, p_, wk_, xv_);

}


double xprime(double __x__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return (1+Curve*__x__)*Pc(0, p_, wk_, xv_)*__px__/Ps(__px__,__py__,__dK__, p_, wk_, xv_);

}


double yprime(double __x__, double __px__, double __py__, double __dK__, double *p_, double *wk_, double *xv_) {


return (1+Curve*__x__)*Pc(0, p_, wk_, xv_)*__py__/Ps(__px__,__py__,__dK__, p_, wk_, xv_);

}


int getindex(char *name, double *p_, double *wk_, double *xv_) {

  if (strcmp(name, "dK")==0)
	return 0;
  else if (strcmp(name, "px")==0)
	return 1;
  else if (strcmp(name, "py")==0)
	return 2;
  else if (strcmp(name, "x")==0)
	return 3;
  else if (strcmp(name, "y")==0)
	return 4;
  else if (strcmp(name, "Curve")==0)
	return 5;
  else if (strcmp(name, "G")==0)
	return 6;
  else if (strcmp(name, "KinEn0")==0)
	return 7;
  else if (strcmp(name, "Length")==0)
	return 8;
  else if (strcmp(name, "Mass0")==0)
	return 9;
  else if (strcmp(name, "clight")==0)
	return 10;
  else if (strcmp(name, "q")==0)
	return 11;
  else {
	fprintf(stderr, "Invalid name %s for getindex call\n", name);
	return 0.0/0.0;
	}
}


int heav(double x_, double *p_, double *wk_, double *xv_) {
  if (x_>0.0) {return 1;} else {return 0;}
}

void auxvars(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){


}


void massMatrix(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobian(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobianParam(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}
